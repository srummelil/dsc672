# From: 
# https://www.digitalocean.com/community/tutorials/a-guide-to-time-series-forecasting-with-arima-in-python-3
# Significantly adapted, but the iterative approach and some code is a direct-use.

def find_best_model(train_years, test_years, df, exogenous_variables, endogenous_variable):
    train_data=df[endogenous_variable].loc[(df.index.year.isin(train_years))]
    exog=df[exogenous_variables].loc[(df.index.year.isin(train_years))].values
    train=train_data.values

    test_data=df[endogenous_variable].loc[(df.index.year.isin(test_years))]
    test=test_data.values

    # Define the p, d and q parameters to take any value between 0 and 2
    p = d = q = range(0, 3)

    # Generate all different combinations of p, q and q triplets
    pdq = list(itertools.product(p, d, q))

    # Generate all different combinations of seasonal p, q and q triplets
    seasonal_pdq = [(x[0], x[1], x[2], len(train)) for x in list(itertools.product(p, d, q))]
    
    warnings.filterwarnings("ignore") # specify to ignore warning messages
    count=1
    for param in pdq:
        for param_seasonal in seasonal_pdq:
            try:
                mod = sm.tsa.statespace.SARIMAX(train,
                                                exog=exog,
                                                order=param,
                                                seasonal_order=param_seasonal,
                                                enforce_stationarity=False,
                                                enforce_invertibility=False)

                results = mod.fit()
                if count==1:
                    tmp_best=results.aic
                    count+=1
                else:
                    if tmp_best > results.aic:
                        tmp_best=results.aic
                        tmp_best_param=param
                        tmp_best_seasonal=param_seasonal
                        count+=1
                    else:
                        count+=1
                    
                print('ARIMA{}x{}12 - AIC:{} - best AIC: {} - Iteration: {}'.format(param,
                                                                                    param_seasonal,
                                                                                    results.aic,
                                                                                    tmp_best,
                                                                                    count))
            
            except Exception as e:
                """print('Exception: {} ARIMA{}x{}12 - Iteration: {}'.format(e,
                                                                          param,
                                                                          param_seasonal,
                                                                          count))"""
                continue
                
    return(tmp_best, tmp_best_param, tmp_best_seasonal)


# Lets split the data into 3 years train, one test, across years. Assumption: That any long-
# term weather trend will not manifest materially within a three year timeframe.

years=[2010, 2011, 2012, 2013]

# Keep: Visibility, Temperature, and Pressure - Pressure has NaN, dropping it.
exogenous_variables=['Visibility', 'Temperature']

#for scenario in scenarios:
for iteration in range(0, len(years)):
    list_len=len(years)
    train_years=years[1:len(years)]
    test_year=[]
    test_year.append(years[0])
    print("Iteration: {} Test: {} Train: {}".format(iteration, test_year, train_years))
    tmp_best, tmp_best_param, tmp_best_seasonal = find_best_model(train_years,
                                                                  test_year,
                                                                  solar_prod_by_day_fnl,
                                                                  exogenous_variables,
                                                                  'Solar_KWH')

    print("Best param: {} Best Seasonal Param: {} best AIC: {}".format(tmp_best_param,
                                                                       tmp_best_seasonal,
                                                                       tmp_best))
    years.append(years.pop(0))

    

